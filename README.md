# Flutter で sqlite のお勉強

Flutter で sqlite のお勉強です。

Flutter では、sqflite パッケージを使用します。

## Persist data with SQLite

[公式の元記事。「Persist data with SQLite」](https://docs.flutter.dev/cookbook/persistence/sqlite)

Flutter 公式 Document に Sqlite を使用している sample 記事があります。

わんちゃんの名前と年齢を登録できる database の sample です。

この sample はコマンドラインベースでした。

このリポジトリは、widget(GUI) で実装します。

## Package to use.

-   sqflite: ^2.3.3
-   path_provider: ^2.1.3
-   path: ^1.9.0

### [path](https://pub.dev/packages/path)

パスに関連した文字列の操作

```
flutter pub add path
```

### [path_provider](https://pub.dev/packages/path_provider)

各プラットフォームで使用可能なローカルのパスの取得

```
flutter pub add path_provider
```

### [sqflite](https://pub.dev/packages/sqflite)

sqlite 使えるパッケージ

```
flutter pub add sqflite
```

> [!NOTE]
> 以降雑記です。

## モデルクラスについて

### 結論

-   モデルクラスは、データの構造とインスタンスのシリアライズ、デシリアライズに専念する。

-   モデルには、データ構造とインスタンスフィールドを変換するメソッドを定義するのがセオリーのようだ。

-   SQL クエリは定義しない。クエリは 「Repository クラス」や「ヘルパー」に任せる。

-   どっかでバリデーションがあってもいいようだ。

-   モデルのフィールドにアクセスする機能は model に寄せたほうがよいと思っている

### 結果

モデルインスタンスのフィールドにアクセスするコードを main から dog.dart に移動したら、綺麗にまとまって記述できた気がする。

dog.dart では、フィールドから文字列にするメソッドをいくつか定義してある。

id: \${dogs[index].id.toString()} / age: \${dogs[index].age.toString()}

↓

dogs[index].toBody()

## クラスについて

クラス は、新しい型を作るイメージ。

int とか String だけではないのだ。自分で作るのだ。

型は多様なプロパティ（フィールド）とメソッドを持つ。

しかし、型は自分らしい、プロパティとメソッドを持つはず。あいつはあいつらしいことしかしないはず。

多様にも限度があるのだ。

モデルも同じく。モデルらしくあるはずなのだ。

### モデルについて

モデルはクラスです。

モデルのフィールドは、テーブル構造に則った構成をしています。

構造体のような基礎的な構造であって、データの集合体を表す型です。

メソッドは持たなくてもよい。

フィールドを操作する場合は、メソッドを持つことになります。

一般的には、シリアライズ、デシリアライズなメソッドを定義するのがセオリーです。

## ヘルパークラス（プロバイダークラス）とモデルクラス

helper や provider とはモデル経由でやり取りをするのがよいのかもしれない。

helper メソッドの引数はモデルをあてがうのがいいかもしれない。

Interface 的な感じか？そーいえばリポジトリパターンは interface を使うようね。

delete などの引数は index である数値でいいとおもうけど。

ヘルパークラスとモデルとメインの分離はレイヤー的な思考なのかな？

## メモ

### Helper / Provider

helper, provider 内で print は副作用かな。

### 例外の実装について

例外をどこにどのように記述するべきかわからない。

> 「予期できて対処可能な例外のみをキャッチし、その他の例外はコールスタックを上位に伝播させ、上位のエラーハンドリングコードによってキャッチされるようにすることが一般的に良い習慣です。これにより、バグの特定と修正が容易になり、アプリケーションで予期しないエラーや挙動を避けることができます。」

### シングルトンパターン

私が初期に出会った、シングルトンの記述方法

プロパティアクセス方式

\_database の null チェックをわかりやすく記述している。

```
Future<Database> get database async {
  if (_database != null) return _database!;
  _database = await _initDatabase();
  return _database!;
}
```

### factory とシングルトン

factory キーワードを使用しなくともシングルトンは使用できます

### Dart

定数は、const だけではダメなようだ、final だけは OK

## お気持ちログ

### 2024/3/11

Card 部分（Dog モデルの展開部分）を描画するコードを分離したほうがいいかな。

モデル（dog.dart）に押し込んだほうがいいかな？

Widget を返す形が良きかも

モデル操作を極力 main.dart から排除したほうがいいかも

main は controller であるべきかな

低レイヤ処理を外に任せて反応するだけにする

### 2024/4/4

レコード追加するメソッドの引数を、バラバラな数値ではなく、モデルを引き渡すようにした

追加時は id は不要なのだが、インスタンス生成時の引数に必要なので 0 としてみた

実際のレコード追加処理では id は使用されない

### 2024/6/2

addDog ではなく insert のほうが抽象的かな。いやでも明確なほうがいいのかな？

### 2024/6/7

関数型のパラダイムを入れていきたいかな

現在は、dogs という変数を持っている。状態である。

変数 1 つ 1 つが、副作用の中心です

シグネチャを介さずアタッチするとその関数が副作用化します。透過性が壊れるのかな？

### 2024/6/19

クエリ文字列をモデルクラスに作成した。

id が必要になった場合工夫が必要かもしれない。update、指定削除とかね。

ユーザ入力に注意しなければならない。SQL インジェクションとかね。

id 引数にすれば動作はするね。

```
Future<int> delete(int id) async {
  return await db.delete(tableTodo, where: '$columnId = ?', whereArgs: [id]);
}
```

### 2024/6/19

dog モデルクラスにクエリも定義したが、それは、アンチパターンのようだ

モデルクラスはデータ構造といくつかのシリアライズ、デシリアライズのメソッドに専念
すべきのようだ。

一方ヘルパークラスではデータベースの作成や操作を定義するのがセオリーのようだ。

### 2024/6/20

関数型プログラミングかぶれがすぎたようだ。

futureBuilder に渡す future を前もって取得するために状態変数の宣言が必要のようだ

よって、「\_dogs」を定義して、futureBuilder に渡すことにした。
